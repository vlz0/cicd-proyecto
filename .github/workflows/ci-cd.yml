# Nombre del Workflow
name: CI/CD Pipeline AWS ECS con CloudFormation

# Disparadores del Workflow
on:
  push:
    branches:
      - main # Se ejecuta en push a la rama main
  pull_request:
    branches:
      - main # Se ejecuta en pull requests hacia main
  workflow_dispatch: # Permite ejecución manual desde la UI de GitHub Actions

env:
  # Staging
  STAGING_CLUSTER_NAME: notas-staging-cluster
  STAGING_SERVICE_NAME: notas-staging-service
  # Production
  PROD_CLUSTER_NAME: notas-production-cluster
  PROD_SERVICE_NAME: notas-production-service

# Definición de los trabajos (Jobs)
jobs:
  # -------------------------------------
  # Job de CI (Build, Test, Publish Docker Image)
  # -------------------------------------
  build-test-publish:
    runs-on: ubuntu-latest
    outputs:
      repo_name: ${{ steps.set_outputs.outputs.repo_name }}
      image_tag: ${{ steps.set_outputs.outputs.image_tag }}

    steps:
      # 1. Checkout del código del repositorio
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Configurar el entorno de Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12' # Especificar versión de Python

      # 3. Cache de dependencias
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip  # La carpeta donde pip guarda la caché en Linux
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # 4. Instalar dependencias de Python
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Instalar paquetes listados en requirements.txt

      # 5. Ejecutar Black (Formateador de código) en modo chequeo
      - name: Run Black (Formatter)
        run: black app --check

      # 6. Ejecutar Pylint (Linter) y guardar reporte
      - name: Run Pylint (Linter)
        run: pylint app --output-format=text --fail-under=9 > pylint-report.txt || true # Continúa aunque falle Pylint (para Sonar)

      # 6. Ejecutar Flake8 (Linter) y guardar reporte
      - name: Run Flake8 (Linter)
        run: flake8 app --output-file=flake8-report.txt || true # Continúa aunque falle Flake8 (para Sonar)

      # 7. Ejecutar Pruebas Unitarias con Pytest y generar reporte de cobertura
      - name: Run Unit Tests with pytest and Coverage
        run: |
          # Ejecuta solo pruebas unitarias, excluyendo aceptación y humo
          pytest --ignore=tests/test_acceptance_app.py --ignore=tests/test_acceptance_simple.py --ignore=tests/test_smoke_app.py

      # SE ELIMINAN DEL JOB DE CI EL PASO DE ACCEPTANCE TESTS, PASA AL JOB DE CD.

      # 7.1. Cargar reportes de cobertura y pruebas unitarias como artefactos
      - name: Upload Test Reports Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-reports
          path: |
            htmlcov/
            report.html

      # 8. Ejecutar análisis con SonarCloud
      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@v5.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}  # Automáticamente proporcionado
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}   # El secreto que creaste

      # --- Pasos de Docker (solo en push a main) ---

      # 9. Configurar QEMU (para buildx multi-plataforma, aunque no lo usemos explícitamente)
      - name: Set up QEMU
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/setup-qemu-action@v3

      # 10. Configurar Docker Buildx (constructor avanzado)
      - name: Set up Docker Buildx
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/setup-buildx-action@v3

      # 11. Iniciar sesión en Docker Hub
      - name: Login to Docker Hub
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      # 12. Construir la imagen Docker localmente
      - name: Build Docker image
        id: build_image
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false   # No subir la imagen todavía
          load: true    # Cargar la imagen en el runner para que Trivy pueda escanearla
          tags: |
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:${{ github.sha }}
            ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:latest
          cache-from: type=gha
          cache-to: type=gha,mode=max

      # 13. Escanear la imagen con Trivy para vulnerabilidades
      - name: Scan Docker image with Trivy
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: '${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:${{ github.sha }}'
          format: 'table'
          exit-code: '1' # El pipeline fallará si se encuentran vulnerabilidades
          severity: 'CRITICAL,HIGH' # Escanear solo por severidades críticas y altas
          ignore-unfixed: true # Ignorar vulnerabilidades que aún no tienen un parche

      # 14. Subir la imagen latest a Docker Hub
      - name: Push Docker image to Docker Hub
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:${{ github.sha }}
          docker push ${{ secrets.DOCKERHUB_USERNAME }}/${{ github.event.repository.name }}:latest

      # 15. Establecer las salidas del job usadas para el despliegue
      - name: Set Job Outputs
        id: set_outputs
        if: github.event_name == 'push' && github.ref == 'refs/heads/main'
        run: |
          echo "repo_name=${{ github.event.repository.name }}" >> $GITHUB_OUTPUT
          echo "image_tag=${{ github.sha }}" >> $GITHUB_OUTPUT


  # -------------------------------------
  # Job de Despliegue CloudFormation Staging
  # -------------------------------------
  deploy-cfn-staging:
    needs: build-test-publish
    uses: ./.github/workflows/deploy.yml
    with:
      stack-name: notas-staging-stack
      environment-name: staging
      repo-name: ${{ needs.build-test-publish.outputs.repo_name }}
      image-tag: ${{ needs.build-test-publish.outputs.image_tag }}
    secrets: inherit

  # -------------------------------------
  # Job de Actualización Servicio Staging (ECS - Forzar despliegue)
  # -------------------------------------
  update-service-staging:
    # Depende de que CFN haya actualizado la Task Definition
    needs: [build-test-publish, deploy-cfn-staging]
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      # 1. Configurar credenciales de AWS (CON SESSION TOKEN)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # <--- USO DEL SESSION TOKEN
          aws-region: us-east-1

      # 2. Forzar un nuevo despliegue en el servicio ECS de Staging
      - name: Force New Deployment ECS Service Staging
        run: |
          echo "Forcing new deployment for Staging service..."
          aws ecs update-service --cluster ${{ env.STAGING_CLUSTER_NAME }} \
                                --service ${{ env.STAGING_SERVICE_NAME }} \
                                --force-new-deployment \
                                --region us-east-1
          # Esperar a que el despliegue se estabilice
          echo "Waiting for Staging service deployment to stabilize..."
          aws ecs wait services-stable --cluster ${{ env.STAGING_CLUSTER_NAME }} --services ${{ env.STAGING_SERVICE_NAME }} --region us-east-1
          echo "Staging service deployment stable."

  # -------------------------------------
  # Job de Pruebas de Aceptación en Staging
  # -------------------------------------
  test-staging:
    needs: [update-service-staging, deploy-cfn-staging] # Depende de que el servicio esté estable con la nueva versión
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      # 1. Checkout del código (para acceder a las pruebas)
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Configurar Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      # 3. Cache de dependencias
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip  # La carpeta donde pip guarda la caché en Linux
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-


      # 4. Instalar dependencias de prueba
      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt # Incluye selenium, pytest

      # 5. Ejecutar pruebas de aceptación contra el entorno de Staging
      - name: Run Acceptance Tests against Staging
        env:
          APP_BASE_URL: ${{ needs.deploy-cfn-staging.outputs.alb_url }} # URL del ALB de Staging desde salidas
        run: |
          echo "Running acceptance tests against: $APP_BASE_URL"
          sleep 90 # Espera prudencial para el registro del target en el ALB
          pytest tests/test_acceptance_app.py -v -s

  # -------------------------------------
  # Job de Despliegue CloudFormation Producción
  # -------------------------------------
  deploy-cfn-prod:
    needs: [build-test-publish, test-staging]
    uses: ./.github/workflows/deploy.yml
    with:
      stack-name: notas-prod-stack
      environment-name: production
      repo-name: ${{ needs.build-test-publish.outputs.repo_name }}
      image-tag: ${{ needs.build-test-publish.outputs.image_tag }}
    secrets: inherit

  # -------------------------------------
  # Job de Actualización Servicio Producción (ECS - Forzar despliegue)
  # -------------------------------------
  update-service-prod:
    needs: [build-test-publish, deploy-cfn-prod] # Depende de que CFN haya actualizado la Task Def de Prod
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      # 1. Configurar credenciales de AWS (CON SESSION TOKEN)
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }} # <--- USO DEL SESSION TOKEN
          aws-region: us-east-1

      # 2. Forzar un nuevo despliegue en el servicio ECS de Producción
      - name: Force New Deployment ECS Service Production
        run: |
          echo "Forcing new deployment for Production service..."
          aws ecs update-service --cluster ${{ env.PROD_CLUSTER_NAME }} \
                                --service ${{ env.PROD_SERVICE_NAME }} \
                                --force-new-deployment \
                                --region us-east-1
          # Esperar a que el despliegue se estabilice
          echo "Waiting for Production service deployment to stabilize..."
          aws ecs wait services-stable --cluster ${{ env.PROD_CLUSTER_NAME }} --services ${{ env.PROD_SERVICE_NAME }} --region us-east-1
          echo "Production service deployment stable."

  # -------------------------------------
  # Job de Pruebas de Humo en Producción
  # -------------------------------------
  smoke-test-prod:
    needs: [update-service-prod, deploy-cfn-prod] # Depende de que el servicio de prod esté estable
    runs-on: ubuntu-latest
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'

    steps:
      # 1. Checkout del código
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Configurar Python
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      # 3. Cache de dependencias
      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip  # La carpeta donde pip guarda la caché en Linux
          key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-pip-

      # 4. Instalar dependencias de prueba
      - name: Install test dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt

      # 5. Ejecutar pruebas de humo contra el entorno de Producción
      - name: Run Smoke Tests against Production
        env:
          APP_BASE_URL: ${{ needs.deploy-cfn-prod.outputs.alb_url }} # URL del ALB de Producción desde salidas
        run: |
          echo "Running smoke tests against: $APP_BASE_URL"
          sleep 30 # Espera prudencial
          pytest tests/test_smoke_app.py # Ejecutar las pruebas de humo

  # -------------------------------------
  # Job de Rollback si fallan las pruebas de humo (VERSIÓN CORREGIDA)
  # -------------------------------------
  rollback-on-failure:
    needs: [smoke-test-prod, build-test-publish]
    runs-on: ubuntu-latest
    if: always() && needs.smoke-test-prod.result == 'failure'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}
          aws-region: us-east-1

      - name: Rollback Staging and Production
        run: |
          STABLE_IMAGE_URI="${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.build-test-publish.outputs.repo_name }}:stable"
          echo "::warning:: Starting rollback to stable image: $STABLE_IMAGE_URI"

          # --- Rollback de Producción ---
          echo "Rolling back Production environment..."
          aws cloudformation deploy \
            --template-file template.yaml \
            --stack-name notas-prod-stack \
            --parameter-overrides \
              EnvironmentName=production \
              DockerImageUri=$STABLE_IMAGE_URI \
              LabRoleArn=${{ secrets.LAB_ROLE_ARN }} \
              VpcId=${{ secrets.VPC_ID }} \
              SubnetIds="${{ secrets.SUBNET_IDS }}" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changes
          aws ecs update-service --cluster ${{ env.PROD_CLUSTER_NAME }} --service ${{ env.PROD_SERVICE_NAME }} --force-new-deployment

          # --- Rollback de Staging ---
          echo "Rolling back Staging environment..."
          aws cloudformation deploy \
            --template-file template.yaml \
            --stack-name notas-staging-stack \
            --parameter-overrides \
              EnvironmentName=staging \
              DockerImageUri=$STABLE_IMAGE_URI \
              LabRoleArn=${{ secrets.LAB_ROLE_ARN }} \
              VpcId=${{ secrets.VPC_ID }} \
              SubnetIds="${{ secrets.SUBNET_IDS }}" \
            --capabilities CAPABILITY_IAM CAPABILITY_NAMED_IAM \
            --no-fail-on-empty-changes
          aws ecs update-service --cluster ${{ env.STAGING_CLUSTER_NAME }} --service ${{ env.STAGING_SERVICE_NAME }} --force-new-deployment
          
          echo "::error::Smoke tests failed! Rollback to 'stable' tag has been completed."

  # -------------------------------------
  # Job para etiquetar la versión estable si todo fue exitoso
  # -------------------------------------
  save-stable-version:
    needs: [smoke-test-prod, build-test-publish]
    runs-on: ubuntu-latest
    if: success()

    steps:
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Tag and Push Stable Image
        run: |
          IMAGE_TAG="${{ needs.build-test-publish.outputs.image_tag }}"
          REPO_NAME="${{ secrets.DOCKERHUB_USERNAME }}/${{ needs.build-test-publish.outputs.repo_name }}"
          
          echo "Pulling newly validated image: $REPO_NAME:$IMAGE_TAG"
          docker pull "$REPO_NAME:$IMAGE_TAG"
          
          echo "Tagging image as stable"
          docker tag "$REPO_NAME:$IMAGE_TAG" "$REPO_NAME:stable"
          
          echo "Pushing stable tag to Docker Hub"
          docker push "$REPO_NAME:stable"